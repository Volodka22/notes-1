# Lecture 1. rvalue-ссылки

+: позволяет уменьшать число копирований

А когда они вообще возникают?
1. При передаче параметров

    ```
        struct mytype {
            ...
        }
        void f(mytype); 
        mytype g();
        
        f(g());  // не будет вызван конструктор копирования mytype, т.к. g() - это rvalue (см. дальше)
    ```
    Во что вообще транслируется вызов при передачи параметров?
    ```
    void f(mytype r) {
        r.a = 42;
    }
    
    mytype y;
    f(y)
    ```
    
    *
        ```
        void f(mytype const& x) {
            mytype x_copy = x;
            x.a = 42;
        }
        
        mytype y;
        f(y);
        ```
        
    *   ```
        void f(mytype& x) {
            x.a = 42;
        }
        
        mytype y;
        {
            mytype y_copy = y;
            f(y_copy);
        }
        ```
        
    Заметим, что иногда мы можем не делать копирование: в 1, если не присваивается ничего; во 2, если передается rvalue (можем заисопльзовать только один раз):
    ```
    f(mytype(1, 2, 3));
    ```
    С++ компиляторы устроены вторым вариантом, и копируют при lvalue, не копируют при rvalue.
    
2. При возвращении значения
    **Return-value optimization (RVO)**
    ```
    mytype g() {
        return mytype(1, 2, 3);
    }
    
    mytype r = g();  // резервирует место под результат, а g() на этом месте коструирует объект 
    ```
    Поэтому транслируется в примерно такое:
    ```
    void g(void* result) {
        // а тут как?
        // (*): конструтор - фукция, принимающая void* this и набор аргументов
        //      деструктор - аналогично, функция, принимающая mytype* this
        // можно подумать тут такой код:
        char tmp[sizeof(mytype)];
        mytype_ctor(tmp, 1, 2, 3);
        mytype_ctor(result, tmp);
        mytype_dtor(tmp);
        // но тут копирование bruh, поэтому так по причине (*):
        mytype_ctor(result, 1, 2, 3);
    }
    
    char x[sizeof(mytype)];  // align кривой, но для примера похуй
    g(x);
    ```
    Раньше на RVO не было требований, с С++17 по стандарту нужно реализовывать.
    Как следствие, рекурсивные коллы не плодят множество копирований, т.к поинтер на result у них равный у всех.
    А если возвращаем локальную переменную?
    ```
    std::string foo() {
        std::string tmp;
        for (;;) {
            tmp += ...;
        }
        return tmp;  // все крупные компиляторы умеют не копировать тут, думая что tmp лежит в result
    }
    ```
    **Named return-value optimization (NRVO)**
    ```
    void foo(std::string* result) {
        std::string_ctor(result);
        for (;;) {
            *result += ...;
        }
    }
    ```
    Такое можно невсегда сделать, например, если в момент создания переменной, которую мы вернем существуют пути исполнения, в результате которых мы вернем не эту переменную, то :( :
    ```
    std::string bar() {
        std::string a("abc");
        std::string b("cde");
        
        if (flag) {
            return a;
        } else {
            return b;
        }
    }
    ```
    
Иногда копирование сохдает проблемы:
```
    vector<string> v;
    string s;
    v.push_back(s);
```
Тут для произвольного типа Т вектор будет вынужден делать копирования при переаллокации вектора на другуя память, а для некоторых можно mem_cpy.
Для некоторых типов это свойство очень пиздово, если например vector<fstream>, то как копировать?
В С++03 так нельзя было писать, люди хранили указатели. А это сложно писать exception-safity и не кэш-френдли. Или через vector<shared_ptr<fstream>>.
unique_ptr тоже не копируемый, т.к. в деструкторе у него delete. ПОэтмоу можем придумать следующую операцию:
```
unique_ptr(unique_ptr& other)  // move
    : ptr(other.ptr) {
    pther.ptr = nullptr;
}

void move(unique_ptr& oither) {
    delete ptr;
    ptr = other.ptr;
    other.ptr = nullptr;
}
```
Это позволило бы держать vector<fstream, даже для тех классов, где нельзя предоставить копирование.
но такая сигнатура мува не очень:
- rvalue не биндитвя в lvalue
-   ```
    vector<auto_ptr<mytype>> v;
    sort(v.begin(), v.end());
    ```
    Все указатели занулятся, т.к. там есть часть quick sort, который не копирует теперь, а мувает.
    
    
    
    
    
# Lecture 2. rvalue-ссылки
Непосредственно про ссылки
```
void push_back(T const&);
vois push_back(T&&); // push_back_move;
```
```
struct mytype {
    mytype(mytype const&);
    mytype(mytype&&); // кэйс в autoptr сюда не подходит, т.к. rvalue не биндит от lvalue
    
    mytype& operato=(mytype const&);
    mytype& operator=(mytype&&);
};
```

В целом это всё.
lvalue -> rvalue:
```
vector<mytype> v;
mytype obj;
// v.push_back(static_cast<mytype&&>(obj));
v.push_back(std::move(obj));
```
Чтобы не писать каст, в стандартной библиотеки есть мув:
```
template <typename T>
T&& std::move(T& obj) { // тут про бинд & -> && не говорили , оригинальный мув другой
    return static_cast<T&&>(obj);
}
```
Мув это не приказ, а совет, будет ли там отбирание владения - зависит от реализации.

Нюансы:
1.  ```
    struct person {
        person(person const& name) 
            : name(name) {}  
        
        person(person&& name)
            : name(name) {}  // тут name это lvalue, т.к. он именнованный
            : name(move(name)) {}  // тут все ок, как ожидается
    
        // Не хочется писать кучу перегрузок, альтернатива:
        person(string name) 
            : name(move(name)) {}
        // так лучше писать, но тут больше операций, т.к. 1 копирование + 1 мув

    };
    ```
    ```
    return move(local_var); // ломает NRVO, да и в целом хуйня которая не работает, очевидно
    ```
    Как проверить, выражение lvalue/rvalue - две перегрузки через явный тип:
    1.  Перегрузки
        ```
        void foo(mytype const&);  // 1
        void foo(mytype&&);  // 2
        
        mytype& lvalue();
        mytype&& rvalue();
        
        foo(lvalue());  // 1
        foo (rvalue());  // 2
        ```
    2.  Copy elision + RVO
        ```
        mytype test() {
            return lvalue();  // no RVO
            return rvalue();  // RVO
        }
        
        mytype x = lvalue();  // copy
        mytype x = rvalue();  // no copy
        ```
    
    ```
    mytype&& wtf();  // результат вызова это какая ссылка?
    foo(wtf());  // 2
    mytype test() {
        return wtf();  //  no RVO
    }
    mytype x = wtf();  // copy
    ```
    Ситуация коненчо мемная получилась. wtf := xvalue - функция которая возвращает &&
    lvalue := lvalue
    rvalue := prvalue
    
    xvalue:
        1. результат функции, возвращающий &&
        2. a.b где a это prvalue
    
    После мува правая часть остается в "неопределенном, но валидном для испольщования состоянии".
    Если бы мув был деструктивным, то есть удалял правую часть, то объект бы разрушался. Но сложнотсь в муве полей структур, т.к. какой-то один компонент тоьлко мувнулся, а развалилась вся структура.
    
    const на ретурн типе запрешает мувать, не хорошо так делать.
        

    
    
    
# Lecture 3. Intrusive контейнеры

Суть в том, чтобы для задачи разделения списка юнитов на какие-то множества не использовать поиск этого юнита в листе, т.к. он большой и, несмотря на то что удаление за О(1), поиск там за О(n). Суть интрузивности -- хранить инфорпмацию о всех списках, в которых находится юнит прямо в юните, как бы прошивая еще одним двусвязным списком элементы множетсва, тогда для удаления какого-то юнита основного листа из его множества нам не придется искать этот элемент в том множетсве, т.к. для него мы знаем его соседей и просто сделаем ужаление, без поиска, за О(1).

Плюсы такого подхода:
+ Нет аллокаций/освобождений при всатвке/удалении элемента 
(актуально при больших объемах множеств)
+ Возможность использовать двусвязный список вместо хеш-таблицы 
(любопытный факт. Он дешевле в вопросе количества требуемых комманд, это по сути константа, а хеши считать все же дольше + локальность ссылок тут ахуеть просто, так что еще и претензии к спискам по поводу кэш-миссов снимаются, т.к. мы работаем всегда с памятью юнитов при переборе)
+ Лучшая локальность ссылок при итерации по элементам

Можно и обычный список приспособить лист к нелинейному поиску через backlink указатель элементов множетсва на элементы листа. Ровно это называют итераторами std::list. Вроде все супер, зачем интрузивность? 
Потому что память.

\+ интрузивности: Мы съэкономили на backlink и value, т.к. указатели элементов множетсва есть и в интрузивной версии.
\- интрузивности: Если элемент не выделен в множество для него все равно хранится интрузивные prev/next поинтеры.

Когда элементов мало это бррр.
А поскольку у нас в хипе меньше объектов это выигрыш в виду накладок аллокаторов.

Всё выше можно обобщить на деревья поиска, списки, хеш-ттаблицы, использующие листы для разрешения коллизий. (LRU-кеш так делает вроде)

**Теперь о том как это все хранить**
- С стайл: структурка с прев/некст поинтерми, в юните статично лежат ноды с поинтерами
Тогда чтобы получить укзатель на юнит имея указать на ноду можно сделать containerof := ptr - offsetof(node, member)
(в ядре Линукса реально такое написано) И нет поводов этому не работать, но в спп иногда ВыЛеЗаЕт ВоРнИнГ с наличием виртуальных функций, например, оффсетов не очень хорошо считается
- Спп стайл: каст от дерайвед к базе сдвигает указатель. Значит можем наследоваться! Только надо шаблонным базы сделать, чтобы индентифицировать их можно было. (ну или делать промежуточные базы бррр)

Но важно, что эти два подхода оба корректны, и там где у одного нет ошибок при касте, не будет и второго, и, наоборот, где они есть у первого, там и будут у второго.

Собственно в этом и заключается интрузивность:
1. не создает сам элементы, а работает с тем что ему передали (в инсерт, в ремув)
2. требует от элементов содержать какие-то дополнительные данные, для прошивки их в списки

Прикольный юз-кейс интрузивных сд:
```
struct person {
  string name;
  string id;
  string company_name;
  size_t age;
};
```
Можем добавить возможность поиска по имени, паспорту, компании, путем провязки соответсвующих полей в интрузивные деревья. (В бусте такой контейнер называется multi_index)

    
    
    
    
# Lecture 4. shared_ptr 

Такой же смарт-поинтер, как и unique_ptr, с единственным отличием -- возможностью копироваться, а удален объект будет, когда удалиться последний из shared_ptr'ов, ссылающихся на него. То есть это указатель, который хранит счетчик ссылок и сам объект. Ремарка сразу, счетчик лежит в отдельном сontrol block, а в поинтрее лежит указатель на объект и контрол блок. 

shared_ptr только отвечает за удаление, а не за доступ к объекту, можно и обычные указатели делать на этот объект. (это очевидно, да, но сорокин упомянул лишний раз)

Шаред поинтер рассчитывает на удаление по delete, так что если это кастомно создается, то надо сообщать ему делитер, которым он будет удалять -- функция, которая будет вызван, когда счетчик ссылок == 0. Делитер лежит там же в контрол блоке. На самом деле тут еще птр ледит на оригинальный объект, потом в алясинг конструкторе это сыграет, чтобы уметь удалять спокойно. 

**Aliasing constructor**
Проблема машины и колеса, если машина умерла, а кто-то ссылается на его колесо, то он спокойно продолжит использовать колесо которое никакой машине уже не принадлежит, что странно. shared_ptr иногда хороший способ хайдить ошибки путем простого продления времения жизни объекта. 

То есть, мы хотим интерфейс, позволяющий хранить машину и колеса как единое целое. Тогда решение называется алясинг конструктор. Это конструктор от шаред поинтера, с которым мы разделин контрол блок:
```
struct wheel {};

struct vehicle {
  std::array<wheel, 4> wheels;  
};

std::share_ptr<vehicle> v(new vehicle());
std::shared_ptr<wheel> w(v, &v->wheels[2]);  // ссылается на 3-е колесо, но делит контрол блок с v
```
Заметим, что тут wheel не может иметь кастомный делитр, т.к. тогда мы хотим разное поведение для объемлющего объекта и его состовляющего, что в целом странно.

Тема с машиной и колесом -- типичный юз кейс алясинг конструктора


Особенность реализации шаред поинтера - две аллокации, по new и по аллокации контрол блока

Этого можно избежать, для этого есть функция make_shared, в который передаются аргументы конструктору, она аллоцирует блок памяти, где одновременно будет контрол блок и наш объект (за одну алокацию), вызовет там конструкторы и вернет шаред поинтер на то, что она создала (я писал вроде через создание инплейс контрол блока и использование его птр'а):
```
struct mytype {
    mytype(int, int, int);
};

std::shared_ptr<mytype> p = std::make_shared<mytype>(1, 2, 3);
```

Стоит использовать make_shared, потому что он крутой. Если передавать в аргумент функции шаред поинтеры (а они вычисляются в произвольном порядке), и второй из них может кинуть excrption, тогда память первого ликнет. А make_shared самостоятельно создаст объект и обернет его, для нас это будет как оусловно одна операция, который не ликнет в таком случае. 


**weak_ptr**
Возможность делить контрол блок, не мешая ему удаляться. Он позволяет создаваться от шаред поинтера, и имеет функцию lock(), которая возвращает shared_ptr от этого объекта, если он еще живой или нулловый шаред поинтер, иначе.

Тогда надо похранить два счетчика ссылок в констрол блоке (обычно пишут с инвариантом, что strong_link != 0 <=> weak_link > 0, тогда будет меньше ебли с проверками). А контрол блок теперь удаляется при weak_link == 0, а объект при strong_link == 0

Юз кейс вик поинтеров -- кэши. Виджет живет в кеше, пока на него кто-то ссылается, то есть сам кеш не мешает ему умирать: 
```
shared_ptr<widget> get_widget(size_t id) {
    static map<int, weak_ptr<widget>> cache;
    auto sp = cache[id].lock();
    if (!sp) {
        cache[id] = sp = load_widget(id);
        // тут sp - shared_ptr, поэтому корректно получается:
        // weak_ptr = (shared_ptr = shared_ptr)
    }
    return sp;
}
```
Но этот код не очень корректный код, там мапа будет анбаунд расти :) Но оно и понятно, человек писал этот код чтобы просто выебнуться, кажется.


Проблема анбаунд роста еще и в том, что помимо объектов, которые не удаляются не удаляются и контрол блоки у объектов, которые удаляются, но попрежнему лежат в мапе

Дальше рассказ про фикс этой проблемы (это начало лекции #5 для y2020 ~ первые 30 минут оттуда)
Самая простая идея -- кастомный делитер, чтобы удалять из мапы при удалении и чистил память за собой. Тогда weak_link-- при удалении из мапы, тогда и удалится контрол блок. Таким образом, в мапе не будет протухших виков, посколько он удалится оттуда при разрушении.


Если есть желание возвращать из функции шаред поинтер на объект, то с обычными функциями все ок, но есть проблемы с this:
```
std::shared_ptr<mytype> foo(std::share_ptr<mytype> const& p) {
    return p;  // ok
}

struct mytype {
    std::share_ptr<mytype> bar() {
    return shared_ptr<mytype>(this);  // тут каждый раз будет создаваться новый контрол блок, что как-то не то что мы хотим, поэтому вариант ниже - решение
};


struct mytype : std::enable_shared_from_this<mytype> {
    std::share_ptr<mytype> bar() {
    return std::shared_from_this();  // внутри хранит вик птр на себы и в нужный момент его лочит
};
```

Так же, как есть касты для обычных указателей, так же есть и для шаред птр весь набор. Они кастуют указатель с сохранением контрол блока.

#Contents

[Lecture 1. rvalue-ссылки](#lecture-1-rvalue-ссылки)
[Lecture 2. rvalue-ссылки](#lecture-2-rvalue-ссылки)
[Lecture 3. Intrusive контейнеры](#lecture-3-intrusive-контейнеры)
[Lecture 4. shared_ptr](#lecture-4-shared_ptr)
[Lecture 5. lambda](#lecture-5-lambda)
[Lecture 6. std::function](#lecture-6-std::function)
[Lecture 7. Сигналы](#lecture-7-сигналы)






# Lecture 1. rvalue-ссылки

+: позволяет уменьшать число копирований

А когда они вообще возникают?
1. При передаче параметров

    ```
        struct mytype {
            ...
        }
        void f(mytype); 
        mytype g();
        
        f(g());  // не будет вызван конструктор копирования mytype, т.к. g() - это rvalue (см. дальше)
    ```
    Во что вообще транслируется вызов при передачи параметров?
    ```
    void f(mytype r) {
        r.a = 42;
    }
    
    mytype y;
    f(y)
    ```
    
    *
        ```
        void f(mytype const& x) {
            mytype x_copy = x;
            x.a = 42;
        }
        
        mytype y;
        f(y);
        ```
        
    *   ```
        void f(mytype& x) {
            x.a = 42;
        }
        
        mytype y;
        {
            mytype y_copy = y;
            f(y_copy);
        }
        ```
        
    Заметим, что иногда мы можем не делать копирование: в 1, если не присваивается ничего; во 2, если передается rvalue (можем заисопльзовать только один раз):
    ```
    f(mytype(1, 2, 3));
    ```
    С++ компиляторы устроены вторым вариантом, и копируют при lvalue, не копируют при rvalue.
    
2. При возвращении значения
    **Return-value optimization (RVO)**
    ```
    mytype g() {
        return mytype(1, 2, 3);
    }
    
    mytype r = g();  // резервирует место под результат, а g() на этом месте коструирует объект 
    ```
    Поэтому транслируется в примерно такое:
    ```
    void g(void* result) {
        // а тут как?
        // (*): конструтор - фукция, принимающая void* this и набор аргументов
        //      деструктор - аналогично, функция, принимающая mytype* this
        // можно подумать тут такой код:
        char tmp[sizeof(mytype)];
        mytype_ctor(tmp, 1, 2, 3);
        mytype_ctor(result, tmp);
        mytype_dtor(tmp);
        // но тут копирование bruh, поэтому так по причине (*):
        mytype_ctor(result, 1, 2, 3);
    }
    
    char x[sizeof(mytype)];  // align кривой, но для примера похуй
    g(x);
    ```
    Раньше на RVO не было требований, с С++17 по стандарту нужно реализовывать.
    Как следствие, рекурсивные коллы не плодят множество копирований, т.к поинтер на result у них равный у всех.
    А если возвращаем локальную переменную?
    ```
    std::string foo() {
        std::string tmp;
        for (;;) {
            tmp += ...;
        }
        return tmp;  // все крупные компиляторы умеют не копировать тут, думая что tmp лежит в result
    }
    ```
    **Named return-value optimization (NRVO)**
    ```
    void foo(std::string* result) {
        std::string_ctor(result);
        for (;;) {
            *result += ...;
        }
    }
    ```
    Такое можно невсегда сделать, например, если в момент создания переменной, которую мы вернем существуют пути исполнения, в результате которых мы вернем не эту переменную, то :( :
    ```
    std::string bar() {
        std::string a("abc");
        std::string b("cde");
        
        if (flag) {
            return a;
        } else {
            return b;
        }
    }
    ```
    
Иногда копирование сохдает проблемы:
```
    vector<string> v;
    string s;
    v.push_back(s);
```
Тут для произвольного типа Т вектор будет вынужден делать копирования при переаллокации вектора на другуя память, а для некоторых можно mem_cpy.
Для некоторых типов это свойство очень пиздово, если например vector<fstream>, то как копировать?
В С++03 так нельзя было писать, люди хранили указатели. А это сложно писать exception-safity и не кэш-френдли. Или через vector<shared_ptr<fstream>>.
unique_ptr тоже не копируемый, т.к. в деструкторе у него delete. ПОэтмоу можем придумать следующую операцию:
```
unique_ptr(unique_ptr& other)  // move
    : ptr(other.ptr) {
    pther.ptr = nullptr;
}

void move(unique_ptr& oither) {
    delete ptr;
    ptr = other.ptr;
    other.ptr = nullptr;
}
```
Это позволило бы держать vector<fstream, даже для тех классов, где нельзя предоставить копирование.
но такая сигнатура мува не очень:
- rvalue не биндитвя в lvalue
-   ```
    vector<auto_ptr<mytype>> v;
    sort(v.begin(), v.end());
    ```
    Все указатели занулятся, т.к. там есть часть quick sort, который не копирует теперь, а мувает.
    
    
    
    
    
# Lecture 2. rvalue-ссылки
Непосредственно про ссылки
```
void push_back(T const&);
vois push_back(T&&); // push_back_move;
```
```
struct mytype {
    mytype(mytype const&);
    mytype(mytype&&); // кэйс в autoptr сюда не подходит, т.к. rvalue не биндит от lvalue
    
    mytype& operato=(mytype const&);
    mytype& operator=(mytype&&);
};
```

В целом это всё.
lvalue -> rvalue:
```
vector<mytype> v;
mytype obj;
// v.push_back(static_cast<mytype&&>(obj));
v.push_back(std::move(obj));
```
Чтобы не писать каст, в стандартной библиотеки есть мув:
```
template <typename T>
T&& std::move(T& obj) { // тут про бинд & -> && не говорили , оригинальный мув другой
    return static_cast<T&&>(obj);
}
```
Мув это не приказ, а совет, будет ли там отбирание владения - зависит от реализации.

Нюансы:
1.  ```
    struct person {
        person(person const& name) 
            : name(name) {}  
        
        person(person&& name)
            : name(name) {}  // тут name это lvalue, т.к. он именнованный
            : name(move(name)) {}  // тут все ок, как ожидается
    
        // Не хочется писать кучу перегрузок, альтернатива:
        person(string name) 
            : name(move(name)) {}
        // так лучше писать, но тут больше операций, т.к. 1 копирование + 1 мув

    };
    ```
    ```
    return move(local_var); // ломает NRVO, да и в целом хуйня которая не работает, очевидно
    ```
    Как проверить, выражение lvalue/rvalue - две перегрузки через явный тип:
    1.  Перегрузки
        ```
        void foo(mytype const&);  // 1
        void foo(mytype&&);  // 2
        
        mytype& lvalue();
        mytype&& rvalue();
        
        foo(lvalue());  // 1
        foo (rvalue());  // 2
        ```
    2.  Copy elision + RVO
        ```
        mytype test() {
            return lvalue();  // no RVO
            return rvalue();  // RVO
        }
        
        mytype x = lvalue();  // copy
        mytype x = rvalue();  // no copy
        ```
    
    ```
    mytype&& wtf();  // результат вызова это какая ссылка?
    foo(wtf());  // 2
    mytype test() {
        return wtf();  //  no RVO
    }
    mytype x = wtf();  // copy
    ```
    Ситуация коненчо мемная получилась. wtf := xvalue - функция которая возвращает &&
    lvalue := lvalue
    rvalue := prvalue
    
    xvalue:
        1. результат функции, возвращающий &&
        2. a.b где a это prvalue
    
    После мува правая часть остается в "неопределенном, но валидном для испольщования состоянии".
    Если бы мув был деструктивным, то есть удалял правую часть, то объект бы разрушался. Но сложнотсь в муве полей структур, т.к. какой-то один компонент тоьлко мувнулся, а развалилась вся структура.
    
    const на ретурн типе запрешает мувать, не хорошо так делать.
        

    
    
    
# Lecture 3. Intrusive контейнеры

Суть в том, чтобы для задачи разделения списка юнитов на какие-то множества не использовать поиск этого юнита в листе, т.к. он большой и, несмотря на то что удаление за О(1), поиск там за О(n). Суть интрузивности -- хранить инфорпмацию о всех списках, в которых находится юнит прямо в юните, как бы прошивая еще одним двусвязным списком элементы множетсва, тогда для удаления какого-то юнита основного листа из его множества нам не придется искать этот элемент в том множетсве, т.к. для него мы знаем его соседей и просто сделаем ужаление, без поиска, за О(1).

Плюсы такого подхода:
+ Нет аллокаций/освобождений при всатвке/удалении элемента 
(актуально при больших объемах множеств)
+ Возможность использовать двусвязный список вместо хеш-таблицы 
(любопытный факт. Он дешевле в вопросе количества требуемых комманд, это по сути константа, а хеши считать все же дольше + локальность ссылок тут ахуеть просто, так что еще и претензии к спискам по поводу кэш-миссов снимаются, т.к. мы работаем всегда с памятью юнитов при переборе)
+ Лучшая локальность ссылок при итерации по элементам

Можно и обычный список приспособить лист к нелинейному поиску через backlink указатель элементов множетсва на элементы листа. Ровно это называют итераторами std::list. Вроде все супер, зачем интрузивность? 
Потому что память.

\+ интрузивности: Мы съэкономили на backlink и value, т.к. указатели элементов множетсва есть и в интрузивной версии.
\- интрузивности: Если элемент не выделен в множество для него все равно хранится интрузивные prev/next поинтеры.

Когда элементов мало это бррр.
А поскольку у нас в хипе меньше объектов это выигрыш в виду накладок аллокаторов.

Всё выше можно обобщить на деревья поиска, списки, хеш-ттаблицы, использующие листы для разрешения коллизий. (LRU-кеш так делает вроде)

**Теперь о том как это все хранить**
- С стайл: структурка с прев/некст поинтерми, в юните статично лежат ноды с поинтерами
Тогда чтобы получить укзатель на юнит имея указать на ноду можно сделать containerof := ptr - offsetof(node, member)
(в ядре Линукса реально такое написано) И нет поводов этому не работать, но в спп иногда ВыЛеЗаЕт ВоРнИнГ с наличием виртуальных функций, например, оффсетов не очень хорошо считается
- Спп стайл: каст от дерайвед к базе сдвигает указатель. Значит можем наследоваться! Только надо шаблонным базы сделать, чтобы индентифицировать их можно было. (ну или делать промежуточные базы бррр)

Но важно, что эти два подхода оба корректны, и там где у одного нет ошибок при касте, не будет и второго, и, наоборот, где они есть у первого, там и будут у второго.

Собственно в этом и заключается интрузивность:
1. не создает сам элементы, а работает с тем что ему передали (в инсерт, в ремув)
2. требует от элементов содержать какие-то дополнительные данные, для прошивки их в списки

Прикольный юз-кейс интрузивных сд:
```
struct person {
  string name;
  string id;
  string company_name;
  size_t age;
};
```
Можем добавить возможность поиска по имени, паспорту, компании, путем провязки соответсвующих полей в интрузивные деревья. (В бусте такой контейнер называется multi_index)

    
    
    
    
# Lecture 4. shared_ptr 

Такой же смарт-поинтер, как и unique_ptr, с единственным отличием -- возможностью копироваться, а удален объект будет, когда удалиться последний из shared_ptr'ов, ссылающихся на него. То есть это указатель, который хранит счетчик ссылок и сам объект. Ремарка сразу, счетчик лежит в отдельном сontrol block, а в поинтрее лежит указатель на объект и контрол блок. 

shared_ptr только отвечает за удаление, а не за доступ к объекту, можно и обычные указатели делать на этот объект. (это очевидно, да, но сорокин упомянул лишний раз)

Шаред поинтер рассчитывает на удаление по delete, так что если это кастомно создается, то надо сообщать ему делитер, которым он будет удалять -- функция, которая будет вызван, когда счетчик ссылок == 0. Делитер лежит там же в контрол блоке. На самом деле тут еще птр ледит на оригинальный объект, потом в алясинг конструкторе это сыграет, чтобы уметь удалять спокойно. 

**Aliasing constructor**
Проблема машины и колеса, если машина умерла, а кто-то ссылается на его колесо, то он спокойно продолжит использовать колесо которое никакой машине уже не принадлежит, что странно. shared_ptr иногда хороший способ хайдить ошибки путем простого продления времения жизни объекта. 

То есть, мы хотим интерфейс, позволяющий хранить машину и колеса как единое целое. Тогда решение называется алясинг конструктор. Это конструктор от шаред поинтера, с которым мы разделин контрол блок:
```
struct wheel {};

struct vehicle {
  std::array<wheel, 4> wheels;  
};

std::share_ptr<vehicle> v(new vehicle());
std::shared_ptr<wheel> w(v, &v->wheels[2]);  // ссылается на 3-е колесо, но делит контрол блок с v
```
Заметим, что тут wheel не может иметь кастомный делитр, т.к. тогда мы хотим разное поведение для объемлющего объекта и его состовляющего, что в целом странно.

Тема с машиной и колесом -- типичный юз кейс алясинг конструктора


Особенность реализации шаред поинтера - две аллокации, по new и по аллокации контрол блока

Этого можно избежать, для этого есть функция make_shared, в который передаются аргументы конструктору, она аллоцирует блок памяти, где одновременно будет контрол блок и наш объект (за одну алокацию), вызовет там конструкторы и вернет шаред поинтер на то, что она создала (я писал вроде через создание инплейс контрол блока и использование его птр'а):
```
struct mytype {
    mytype(int, int, int);
};

std::shared_ptr<mytype> p = std::make_shared<mytype>(1, 2, 3);
```

Стоит использовать make_shared, потому что он крутой. Если передавать в аргумент функции шаред поинтеры (а они вычисляются в произвольном порядке), и второй из них может кинуть excrption, тогда память первого ликнет. А make_shared самостоятельно создаст объект и обернет его, для нас это будет как оусловно одна операция, который не ликнет в таком случае. 


**weak_ptr**
Возможность делить контрол блок, не мешая ему удаляться. Он позволяет создаваться от шаред поинтера, и имеет функцию lock(), которая возвращает shared_ptr от этого объекта, если он еще живой или нулловый шаред поинтер, иначе.

Тогда надо похранить два счетчика ссылок в констрол блоке (обычно пишут с инвариантом, что strong_link != 0 <=> weak_link > 0, тогда будет меньше ебли с проверками). А контрол блок теперь удаляется при weak_link == 0, а объект при strong_link == 0

Юз кейс вик поинтеров -- кэши. Виджет живет в кеше, пока на него кто-то ссылается, то есть сам кеш не мешает ему умирать: 
```
shared_ptr<widget> get_widget(size_t id) {
    static map<int, weak_ptr<widget>> cache;
    auto sp = cache[id].lock();
    if (!sp) {
        cache[id] = sp = load_widget(id);
        // тут sp - shared_ptr, поэтому корректно получается:
        // weak_ptr = (shared_ptr = shared_ptr)
    }
    return sp;
}
```
Но этот код не очень корректный код, там мапа будет анбаунд расти :) Но оно и понятно, человек писал этот код чтобы просто выебнуться, кажется.


Проблема анбаунд роста еще и в том, что помимо объектов, которые не удаляются не удаляются и контрол блоки у объектов, которые удаляются, но попрежнему лежат в мапе

Дальше рассказ про фикс этой проблемы (это начало лекции #5 для y2020 ~ первые 30 минут оттуда)
Самая простая идея -- кастомный делитер, чтобы удалять из мапы при удалении и чистил память за собой. Тогда weak_link-- при удалении из мапы, тогда и удалится контрол блок. Таким образом, в мапе не будет протухших виков, посколько он удалится оттуда при разрушении.


Если есть желание возвращать из функции шаред поинтер на объект, то с обычными функциями все ок, но есть проблемы с this:
```
std::shared_ptr<mytype> foo(std::share_ptr<mytype> const& p) {
    return p;  // ok
}

struct mytype {
    std::share_ptr<mytype> bar() {
    return shared_ptr<mytype>(this);  // тут каждый раз будет создаваться новый контрол блок, что как-то не то что мы хотим, поэтому вариант ниже - решение
};


struct mytype : std::enable_shared_from_this<mytype> {
    std::share_ptr<mytype> bar() {
    return std::shared_from_this();  // внутри хранит вик птр на себы и в нужный момент его лочит
};
```

Так же, как есть касты для обычных указателей, так же есть и для шаред птр весь набор. Они кастуют указатель с сохранением контрол блока.


    
    
    
# Lecture 5. lambda

Тут пример про сортировку и то, как передать туда компаратор: 1 - как функцию (T const& a, T const& b), 2 - как оператор() у какого то класса. По тестам получается, что 1-ый вариант медленнее. Почему? тут связано с тем, сколько время проводится в сорте и сколько в колбэке. Проблема в том, что компилятор не может инлайнить функцию в первом варианте:

Как вообще организовать sort?
1.  шаблонно по компаратору
    ```
    template <typename Sort>
    void sort(Comp cmp) {
        ...
        cmp(a, b);
        ...
    }
    
    struct less {
        bool operator()(int a, int b) const {
            return a < b;
        }
    };
    
    sort(less());
    ```
2. принять указатель на функцию
    ```
    void sort(bool (*cmp)(int, int)) {
        ...
        cmp(a, b);
        ...
    }
    
    bool less(int a, int b) {
        return a < b;
    }
    
    sort(&less);
    ```
    
Вроде одно и то же, но разница в том, что если будут вызовы сорт с разными компараторами, то в 1м случае нагенерится куча кода, где можно инлайнить тело компаратора, а во 2м особо ничего не сделать, т.к. функция одна, а вызов функции тяжелый из-за сохранения регистров и прочей возни перед jump. + компилятор может лучше оптимизировать при инлайне, т.к. ему больше информации известно из окружения.

Это сравнение называется **разница между статическим (1) и динамическим (2) полиморфизмом** (с разными объектами работаем одинаково)

Но есть и минусы у статического:
\-: компайл-тайм штука => менее гибкий, ограничевается возможность действий над такими компараторами
\-: генерирует больше кода => меньше шансов попасть в кеш :(

Если скомпилировать с -O2 -flto (linking time optimization -- оптимизация между всеми .cpp не на этапе трансляции, а на этапе линковки [тогда например, можно инлайнить тела функции из одной еденица трансляции в дргую]), то разница пропадет, но это странно, у нас был один .спп .

Если добавить сравнение еще и про greater, то разница опять появляется. Это потому что раньше уомпилятор понял, что в динамическом варинте всегда пихают одну и ту же функцию, и просто инлайнул ее. Поэтому нельщя говорить, что разница в полимозфизмах это хуйня, и скидывать все на компилятор, пусть он разбирается.

То же самое с -O3 -- разницы снова нет. Тут вклад от -fipa_cp_clone, которая в -O3 есть. Суть в том, чтобы делать копии для каких-то констант, что может быть полезно. Тут полезно, и он откопировал динамический сорт. (обычно этот ключ выключен, т.к. просто бесполезен)

Еще один сорт оптимизаций: девиртуализация. Суть: заметить, что часто на месте динамической функции используется какая-то конкретная, подменить ее вызов ифом на сравнение с той, которую мы заметили. Тогда магия скедуллера все сделает + заинлайнили less.
```
void sort(bool (*cmp)(int, int)) {
    for (;;) {
        ...
        if (cmpr == less) {
            less(a, b);
        } else {
            cmp(a, b);
        }
        ...
    }
}
```
На самом деле этот иф -- инвариант всего фора, и там не просто инлайн less, там ?инлайн? всего фора:
```
void sort(bool (*cmp)(int, int)) {
    if (cmpr == less) {
        for (;;) {
            ...
            less(a, b);
            ...
        }
    } else {
        for (;;) {
            ...
            cmp(a, b);
            ...
        }
    }
}
```
MAGIC

Это все круто конечно в большинстве функции, но если важно, насколько эффективный сорт, то тут есть недостаток в виде огромного бинаря, зависящего от кучи факторов.

Этот трик хорошо работает вместе с **PGO (profile-guided optimization)** -- оптимизация, когда дважды компилируется программа: 1ый с подсчетом статистики и запуске на своих тестах, 2ой с применением оптимизации статистикой. -fprofile-generate -fprofile-use.

Про статический и динамический полиморфизм всё

**Анонимные функции**
Хотим отсортировать массив modulo 5. До С++11 - напишем функциональный объект с оператором() (1).
\+ решение, если используется повторно
\- иначе долго писать и непоянтно зачем это надо
\- ПрИдУмАтЬ иМя

С С++11:
[](int a, int b) {return a % 5 < b % 5;}  // (2) 
// это лямбда, и (2) эквивалентна (1)

Лямбда -- класс с именем, которое нам неизвестно, есть оператор() с тем что передано в () и {}

**Синтаксис лямбд**
1. захватывается с контекстом
    если осртировать по модулю N, в (1) надо хранить его в классе, в (2):
    [n](int a, int b) {return a % n < b % n;}  // говорят "захватывает n"
    Можно такое: 
    - []  // ничего
    - [a, b, c]  // по значению
    - [a, b, &c, &d]  // 3 и 4 по ссылке
    - [&, c, d]  // все по ссылке, c и d по значению
    - [=]
    - [&]
    - [this]  // [=] [&] тоже захватывают this, но можно и явно

    Важно, в [] только локальные переменные и аргументы, глобальные переменные там быть не могут (очевидно)
    
2. Может захотеться иметь шаблонный оператор()
    Тут про разницу шаблонности класса и шаблонности метода, и в разных кейсах хочется по разному. Для лямбд есть два спасоба:
    1. ```template<typeaname>(T a, T b)```
    2. ```(auto a, auto b)``` <=> ```template<typename A, typename B>(A a, B b)```
3. ретурн тип можно написать через ```->```

Лямбда *без захвата* может приводиться к указателю на функцию. Тогда тот пример с modulo N для динамического сорта не реализовать, надо обарачивать в функцию принимающую еще и N и на нем вызывать cmp.

Лямбда не имеет дефолного конструктора, оператора=, но могут копироваться и муваться (до С++20). В С++20 лямбдам без захвата рарешили дефолт конструктор и опратор=.

А зачем дефолт конструтор? В целом не зачем, раз не было. Но поскольку даже пустой класс имеет размер 1 байт из-за *паддинга* (std::bind [кто это?] хранит в себе кучу пустых объектов => имеет большой вес) -- по свойству различия адресов любых объектов. Можно наследованием обойти, но \-: если компаратор final, то сосем. Альтернатива -- [[no_unique_address]] (C++20) атрибут, говорящий разместить где-то, похую на адрес (вероятно, адрес этого объекта будет просто this)


    
    
    
# Lecture 6. std::function

Понятно, что поскольку лямбда генерирует новый класс, то в сорте будет статический полиморфизм, и всегда будет быстро :)

Но что, если хочется разные виды динамического полиморфизма?
```
if (flag) {
    func = []() {...}
} else {
    func = []() {...}  // или std::less
}
```

Тоже понятно, что так не написать, т.к. это совершенно разные типы. Как писать? 
? Указатель? 
\- Только если лямбда капчерит ничего 

```
(flag == true ? []() {...} : []() {...});  // в тернарнике это тоже разные типы если что
```


Решение:
**std::function<bool (int, int)> func;**

Как такое написать? (на самом деле там целая практика была, но ладно я ноутесы поделаю хули мне)

Про мемную сигнатуру - это сигнатура функции, эмулируется так:

```
template <typename T>
struct function;

template <typename R, typename ...Args>
struct function<R (Args...)>;
```
Дальше описан function<int (int)> чтобы не ебаться с шаблонами.
```
struct function {
    template <typename F>
    function(F f) 
        : p(new F(move(f))) {}
    
    // деструктор написать не можем, поскольку для delete надо знать тип, а он void* :O
    // можно сохранить делитер в конструкторе, т.к. мы его там знаем
    
    void* p;  // тут непонятно, что хранить, но пусть будет void* пока
};
```
Есть два принципиальных подхода: с наследованием и без (о, как неожиданно ебать).
Hint:

```
template <typename F>
void destroy(void* p) {
    delete static_cast<F*>(p);
}
template <typename F>
void destroy(void* p, int arg) {
    return (*static_cast<F*>(p))(arg);
}
```
Тогда:
```
struct function {
    template <typename F>
    function(F f) 
        : p(new F(move(f))),
        deleter(&destroy<F>) 
        invoker(&invoke<F>) {}
    
    ~function() {
        deleter();
    }
    
    // invoke аналогично dtor
    
    void* p;
    void (*deleter)(void*);
    int (*invoker)(void*, int);
};
```
(на практике вроде наследовался)

Статически полиморфные лямбды и динамически полиморфные std::function позволяют управлять тем, какой нужен полиморфизм, где.


**boost::any**
Хранит вообще всё, что копируется, привет джс.

*Напоминалка про виртуальный деструктор*
Можно сделать обертку над Т и базу, нешаблонную базу, чтобы эту обертку сохранить в эни.
```
struct concept_ {
    virtual ~concept_() {}  
};

template <typename T>
struct model : concept_ {
    model(T value)
        : value(move(vlaue)) {}
    
    T value;
};

struct any {
  template <typename T>
  any(T val) 
    : p(new model<T>(move(val)) {}
  
  ~any() {
      delete p;  // можно и unique_ptr тут вообще
  }
  
  concept_* p;
};
```

Как any_cast сделать? Виртуальная функция не может быть шаблонной, т.к. нам их окнечное число можно позволить. А тут в концепт надо засунуть. Вроде dynamic_cast подойдет. Или через typeid что-то.

Можно function и any реализовывать обоими способами.

Тогда вопрос, а как any_cast делать в случает написания как для function, когда динамик каста нет и тайпадйи тоже, т.к. они работают с виртуальными функциями только. Можно проверить ```deleter == &destroy<mytype>```, так можем узнать, лежит ли в нас mytype. (красиво)


Заметим, что оба способа не хранят явно тип объекта, это называется **Type Erasure**

Об этом можно думать, как о забывании информации о том какой у нас функциональный объект, поскольку нам важны только его функциональные части -- что принимает, что возвращает.


Экскурсия в зоопрарк, привет КПК: **boost::any_iterator<int>**. Если хочется полимормно пользоваться интераторами листа и вектора, например, похожие же структуры.. И пусть даже забъем, что итераторы бывают пяти разных категорий (напоминалка: input, output, forward, bidirectional, random-access) Тогда мы срезаем инфу, что это итератор на вектор, но оставляем, что он на инт. (в бусте есть any_range :| ) И вообще люди пробуют библитеку any_всего написать.

Тайп эрейзнутые классы напоминают наследование, как альтернатива ему.

Мнения по тайп эрешью?
\+: Наследование интрузивное, а мы нет
То есть интератор должен знать, в каких полиморфных отношениях он используется -- это плохо, поскольку что-то будучи полиморфным, не всегда самая очевидная вещь. 
\+: Value-семантика.
    Чтобы пользоваться классом полиморфно надо передавать на него указатель или ссылку. Тогда для вектора таких any надо хранить указатели, а значит виртуальные деструткоры :/ или смарт-поинтры
    **value-семантика** -- про объекты с которыми просто работать в плане копирования и т.д. (std::vector, например, а поинтеры это нет)
    Так вот, виртуальные функции вынуждают пользоваться указателями, теряя value-семантику. А тайп эрезнутые ее имеют
\+-: привязанность к динамическому стораджу
    Можно избежать путем small object, но когда у нас дохуя альтернатив, sorry, от динамических аллокаций особо никуда не деться.
\+: позволяет не пользоваться полиморфизмом, без доплаты за это

Почему тогда any нет в std? Он бесполезный :) Типо any_iterator убивает множество оптимизаций, поэтому большого смысла в них нет. 

Throwback to function:
как написать тайпдеф на указатель на функцию?
```
void (*deleter)(void* p);
typedef void (*deleter_t)(void* p);
```

Шаблонный тайпдеф := using (а typedef не рассширен до шаблонов)
```
template <typename T>
using deleter_t = (*)(T* p);
```

    
    
    
   
# Lecture 7. Сигналы


signal = listener = observer. Это рассказ НЕ ПРО UNIX сигналы.

Зачем это нужно? Это подписка на событие -- вызов callback после произошедствия какого-то действия. Поскольку одного callback может быть недостаточно, то сигналом называют _контейнер function'ов_.

По этому тоже была практика, которую лучше почитать, т.к. там описывались поинтереснее решения всяких проблем, тут нотесы с кодом тоже будут, но, возможно, не так подробно.

Наивно это выглядит так:
```
struct signal {
    using slot_t = function<void()>;
    
    void connect(slot_t slot) {
        slots.push_back(move(slot));
    }
    
    void operator()() const {  // это immit
        for (slot_t const& slot : slots) {
            slot();
        }
    }
    
private:
    vector<slot_t> slots;  // callback называют слотом, соу это они  
};
```

Хочется конечно и disconnect иметь. connect в свою очережь обычно возвращает какой-то connection, удобно его итебатором сделать, да и для дисконнекта мапа приятнее будет. So:
```
strcut connection {

    // ctor 
    
    void disconnect() {
        size_t c = sig->slots.erase(id);
        assert(c == 1);
    }
    
    signal* sig;
    id_t id;
};

struct signal {
    using id_t = uint64_t;
    using slot_t = function<void()>;
    
    connection connect(slot_t slot) {
        id_t id = next_id++;
        slots.insert({id, move(slot)});
        return connection(this, id);
    }
    
    void operator()() const {
        for (auto it = slots.begin(); it != slots.end(); ++it) {
            it->second();
        }
    }
    
private:
    unordered_map<id_t, slot_t> slots;
    id_t next_id = 0;
};
```

Это похоже на правду, но он часто не приминим, т.к. будет ломаться при некоторой последовательности вызовов наших функций. + если какой-то колбэк не ноуэксепт, то вроде получаем странное поведение, однако многи ебилиотеки кладут хуй на это, в том числе и буст, так что последуем их примеру и не будем писать трай-кэтч с логированием.

Проблема тут в следующем, рассмотрим такой класс:
```
struct mytype {
    mytype()
        : c(global_timer.connect(
            [this]{on_timer_elapsed()}
            )) {}
    
    void on_timer_elapsed() {
        c.desconnect();
    }
    
    connection c;
};
```
Логика такая: подписались, произошло событие, мы отписались. Не то что бы редкий случай.  Тогда проблема в оператор(), поскольку при дисконнекте инвалидируется интератор, рассмотрим коллстэк:
```
operator()
|---on_timer_elapsed()
    |---disconnect()  // тут и сломается при ++it
```

Решить можно созданием очереди на удаление: если мы находимся в опереторе() и делается дисконнект, то просто забьем пустым фанкшеном нужный слот, и потом прочистим мапу. Если просто вызван дисконнект, то честно можено удалить слот, поэтоу заведем еще и флаг, в иммите мы дисконнектимся или нет (иначе мапа будет анбунд расти, если коннекты и дисконнекты случаются, а иммит не вызывается) + так как теперь мы удаляем слоты в константном иммите, сделаем мапу мутабельной:

```
strcut connection {

    // ctor 
    
    void disconnect() {
        if (sig->inside_imit) {
            auto it = sig->slots.find(id);
            assert(it != sig->clots.end());
            it->second = slot_t();  // отмечаем, что слот удален
        } else {
            size_t c = sig->slots.erase(id);
            assert(c == 1);
        }
            
    }
    
    signal* sig;
    id_t id;
};

struct signal {
    using id_t = uint64_t;
    using slot_t = function<void()>;
    
    connection connect(slot_t slot) {
        id_t id = next_id++;
        slots.insert({id, move(slot)});
        return connection(this, id);
    }
    
    void operator()() const {
        inside_imit = true;
        for (auto it = slots.begin(); it != slots.end(); ++it) {
            if (it->second) {
                it->second();
            }
        }
        inside_imit = false;
        
        for (auto it = slots.begin(); it != slots.end(); ) {
            if (it->second) {
                ++it;
            } else {
                it = slots.erase(it);
            }
        }
    }
    
private:
    mutable unordered_map<id_t, slot_t> slots;
    id_t next_id = 0;
    mutable bool inside_imit = false;
};
```
Какие теперь тут проблемы?
- смущает пара inside_imit = true/false, можно обернуть в РАИИ. Т.к. она не эксепшн-сэйв, фикс:

```
    void operator()() const {
        inside_imit = true;
        try {
            for (auto it = slots.begin(); it != slots.end(); ++it) {
                if (it->second) {
                    it->second();
                }
            }
        } catch(...) {
            inside_imit = false;
            throw;
        }
        
        inside_imit = false;
  
        for (auto it = slots.begin(); it != slots.end(); ) {
            if (it->second) {
                ++it;
            } else {
                it = slots.erase(it);
            }
        }
    }
```

- еще проблема: наш инвариант - будучи внутри иммита, мы можем иметь пустые слоты, по выходу из иммита их в мапе быть не должно. Тогда прочистку надо делать и внутри кэтча:
```
    void leave_immit() {
        inside_immit = false;
        for (auto it = slots.begin(); it != slots.end(); ) {
            if (it->second) {
                ++it;
            } else {
                it = slots.erase(it);
            }
        }
    }
    void operator()() const {
        inside_imit = true;
        try {
            for (auto it = slots.begin(); it != slots.end(); ++it) {
                if (it->second) {
                    it->second();
                }
            }
        } catch(...) {
            leave_immit();
            throw;
        }
        
        leave_immit();
    }
```
- Все равно хуйня: до сих пор выставляем пару тру-фолс у inside_immit, а представьте такой коллстэк:
```
operator()
|---handler()
    |---operator() // по выходу inside_immit == false;
    |---disconnect() // получили инвалидный итератор
```

Варианты?
1. ЗаПрЕтИтЬ (потому что нахуй такое поведение вообще поддерживать)
2. пофиксим просто? (ведь может быть такое) подсчитывая глубину inside_immit (вообще такие реализации с флагами в тру/фолс много когда сосут при рекурсии, лучше так не делать)

```
strcut connection {

    // ctor 
    
    void disconnect() {
        if (sig->inside_imit != 0) {
            auto it = sig->slots.find(id);
            assert(it != sig->clots.end());
            it->second = slot_t();  // отмечаем, что слот удален
        } else {
            size_t c = sig->slots.erase(id);
            assert(c == 1);
        }
            
    }
    
    signal* sig;
    id_t id;
};

struct signal {
    using id_t = uint64_t;
    using slot_t = function<void()>;
    
    connection connect(slot_t slot) {
        id_t id = next_id++;
        slots.insert({id, move(slot)});
        return connection(this, id);
    }
    
    void leave_immit() {
        --inside_immit;
        for (auto it = slots.begin(); it != slots.end(); ) {
            if (it->second) {
                ++it;
            } else {
                it = slots.erase(it);
            }
        }
    }
    void operator()() const {
        ++inside_immit;
        try {
            for (auto it = slots.begin(); it != slots.end(); ++it) {
                if (it->second) {
                    it->second();
                }
            }
        } catch(...) {
            leave_immit();
            throw;
        }
        
        leave_immit();
    }
    
private:
    mutable unordered_map<id_t, slot_t> slots;
    id_t next_id = 0;
    mutable size_t inside_imit = 0;
};
```

Попрежнему есть проблемы, но в том коде, который еще не написан :|  Деструктор сигнала может быть вызван внутри иммита. Разъёб просто! И такое реально встречается: создается таймер, который при тике удаляется -- ровно этот случай. А у нас будет проблема в иммите тогда, поскольку мапа, по которой итерируемся, протухнет и всё. Чо делать? Флаг не поставить, он же при удалении сигнала и сам удалится. Идея -- сделать это без динамических аллокаций, типо можно было просто в шаред_птр обернуть мапу и жить. Сохраним указатель на локальную переменную, уничтожены мы или нет, тогда эта переменная не будет разрушена при разрушении класса: 

```
strcut connection {

    // ctor 
    
    void disconnect() {
        if (sig->inside_imit != 0) {
            auto it = sig->slots.find(id);
            assert(it != sig->clots.end());
            it->second = slot_t();  // отмечаем, что слот удален
        } else {
            size_t c = sig->slots.erase(id);
            assert(c == 1);
        }
            
    }
    
    signal* sig;
    id_t id;
};

struct signal {
    using id_t = uint64_t;
    using slot_t = function<void()>;
    
    connection connect(slot_t slot) {
        id_t id = next_id++;
        slots.insert({id, move(slot)});
        return connection(this, id);
    }
    
    ~signal() {
        if (is_destroyed) {
            *is_destroyed = true;
        }
    }
    
    void leave_immit() {
        is_destroyed = old_destroyed; // понятно, что это нескомпилируется, но похуй, это же пример :)
        // по хорошему надо бы написать РАИИ класс где можно похранить old_destroyed
        --inside_immit;
        for (auto it = slots.begin(); it != slots.end(); ) {
            if (it->second) {
                ++it;
            } else {
                it = slots.erase(it);
            }
        }
    }
    void operator()() const {
        bool* old_destroyed = is_destroyed;  // чтобы не сломать рекурсию
        bool flag = false;
        is_destroyed = &flag;
        ++inside_immit;
        try {
            for (auto it = slots.begin(); it != slots.end(); ++it) {
                if (it->second) {
                    it->second();
                    if (flag) {
                        old_destroyed = true; // тут передаем выше флаг, что мы разрушены
                        return;
                    }
                }
            }
        } catch(...) {
            leave_immit();
            throw;
        }
        
        leave_immit();
    }
    
private:
    mutable unordered_map<id_t, slot_t> slots;
    id_t next_id = 0;
    mutable size_t inside_imit = 0;
    mutable bool* is_destroyed;
};
```
Заметим, что теперь вроде все работает, но это можно и подупростить:
- не нужен inside_immit -- мы можем определять это по флагу is_destroyed
- не нужна мапа с айдишниками -- можно использовать лист для слотов, тогда айдишником будет итератор листа


В итоге получаем, что простая на первый взгляд идея выглядит как полный пиздец. А вообще зачем это все?
1. Не пытайтесь писать подобные классы самостоятельно, пользуйтесь библиотеками, чтобы не породить множество проблем, которые, как видим, не сложно породить. Однако, обязательно изучите, какие гарантии она предоставляет, потому что мы здесь описали весьма полно. Часто в реализациях не выполняется свойство, что после дисконнекста слот не будет вызван. Что запрещает отписываться в деструкторе. треш..
2. Если конечно не хочется тащить библиотеку только из-за сигнала, можно ебануть самописанный сигнал, но ассертить все кэйсы, которые могут возникнуть, но бы не хотели их видеть. Благо сейчас мы знаем эти кейсы.
3. Те проблемы при последовательности вызовов одних функций внутри других имеет название -- **reentrancing**. В 80-90ых это много обсуждалось, сейчас всем как-то похуй. Это потому что раньше часто пользовались глобальными переменными, а сейчас все такие люди "передохли" (с). Поэтому реэнтрабельность кода сейчас второстепенная проблема, которая часто и не возникает, однако, как видим, она бывает актуальна и без глобальных переменных.


Мораль всей истории: защищая свой код от внешнего воздействия, подумайте о том, насколько защищен ваш код внутри себя. Если мы вызываем кого-то наружу, что он может вызывать обратно у нас? И обратно, если пишешь обработчик.

Получилось какое-то филосовское завершение. Но даже локально при наследование такие проблемы могут возникать -- базовый класс вызывает производный, какие тогда функции может обратно вызывать производный, чтобы ничего не ебнулось в совокупности.
